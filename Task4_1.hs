module Task4_1 where

{-
  Задание 4.1
  Реализация монады над функцией.
  Реализуйте все требуемые классы типов и объясните, почему они реализованы именно так.
-}

-- Монада над функцией. В качестве входного значения `fun` может быть что угодно
-- Собственно, почему бы не `String`?
data FunMonad a = FunMonad { fun :: String -> a }

-------------------- реализуйте класс `Functor` для типа `FunMonad`-------------------------

--Внутри функтора мы реализовали функцию fmap (он же <$>) - это функция реализована таким образом, 
--что мы берем на вход некую функцию f и некоторый функтор(например (FunMonad fun)), 
--а затем помещаем функцию f внутрь контекста и таким образом возвращает новый функтор. 
--По сути когда мы принимаем fmap к функции то по сути мы делаем просто композицию функций

instance Functor FunMonad where
  fmap f (FunMonad fun) = FunMonad (f . fun)

--------------------- реализуйте класс `Applicative` для типа `FunMonad`----------------------

-- в случае с апликативным функтором наша функция также упаковано в контекст (как и у функтора)
-- но теперь и вторая функция также упакована в контекст.

-- pure - функция которая всегда будет возвращать только нашу функцию
-- функция ниже - работает с двумя аргументами, в ней мы последовательно применяем наш аргумент 
-- к первой функции а затем вместе с результатом передаем во вторую (т.е мы как бы достаем функции
-- из контекста и применяем к значению)

instance Applicative FunMonad where
   pure f = FunMonad(\x -> f)
   (<*>) (FunMonad fl) (FunMonad fr) = FunMonad (\x -> fl x $ fr x)

------------------------ реализуйте класс `Monad` для типа `FunMonad`-------------------------

-- Монады применяют функци к упакованному значению и возвращают также упакованное значение 

--  return по большому счету делает тоже самое что и pure в апликативном функторе
-- (>==) знак связывания, с его помощью мы описываем применение функции f, результат которой
-- будет помещен в контекст foo. Cначала мы достаем из контекста аргумент и применяем  
-- функцию foo x, а затем применяем функцию fun к которой еще применяем x

instance Monad FunMonad where
  return f = FunMonad (\x -> f)
  (>>=) (FunMonad foo) f = FunMonad (\x -> fun (f (foo x)) x)